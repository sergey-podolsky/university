/* * * * * * * * * * * * * * * * * 
 * Лабораторная работа №1
 * (работа со строками)
 *
 *		Выполнил:
 * Подольский Сергей
 * группа: КВ-64
 *
 *		Описание проекта:
 * mystring.h - содержит прототипы функций;
 * mystring.c - содержит определеня функций;
 * stringtest.c -  тест-драйв, демонстрирующий работоспособность функций
 * * * * * * * * * * * * * * * * */


#ifndef mystring_h_
#define mystring_h_

int substr(char *string1, char *string2);
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * возвращает индекс элемента в строке string1, с которого начинается подстрока, равная string2. 
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


char *compact(char *string, int count);
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * выполняет процедуру "сжатия" исходной последовательности символов string :
 * каждая подпоследовательность из вхождений одного и того же символа, заменяется на текст x(k),
 * где x - символ, а k - число его вхождений. count - минимальное число вхождений, которое уже следует "сжимать".
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

int subseq(char *string1, char *string2);
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * возвращает длину наибольшей  общей подпоследовательности символов строк string1 и string2.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

char addword(char *word, char *arr, int size);
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * В массиве символов arr записаны слова, разделенные символом '\0'.
 * Функция проверяет есть ли слово, word в массиве; если нет  -  записывает его в конец массива.
 * Возвращаемый результат: -1 – переполнение массива ; 0 – слово уже есть в масииве; 1 – слово добавлено.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

char **sort(char **strings, int size);
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Функция получает в качестве параметра указатель на массив из  указателей типа char*,
 * каждый из которых ссылается на строку.
 * Функция "упорядочивает" строки в лексикографическом порядке.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

char ispal(char *string);
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * возвращает 1, если string является палиндромом и 0 – в противном случае.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

char* makepal(char *);
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * получает в качестве параметра строку символов,
 * преобразует ее в палиндром добавляя к ней наименьшее число символов и возвращает указатель на него.
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

double *txt2double(char *, int *size);
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Первый параметр –  указатель на строку,
 * в которой размещены числа, разделенные символом “;” ,
 * например,  “1123.45;13;3.14”.
 * Функция txt2double() размещает эти числа в динамическом массиве и возвращает указатель на него.
 * Параметр size принимает значение, равное длине массива в случае удачного завершения функции и 0 – в противном случае
 * (т.е. если  хотябы одно из чисел в строке невозможно  корректно преобразовать).
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#endif