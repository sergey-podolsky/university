/* * * * * * * * * * * * * * * * * 
 * Лабораторная работа №2
 * (Рекурсивные структуры данных)
 *
 *		Выполнил:
 * Подольский Сергей
 * группа: КВ-64
 *
 *		Описание проекта:
 * Lab2.h - содержит прототипы функций;
 * Lab2.c - содержит определеня функций;
 * Lab2test.c -  тест-драйв, демонстрирующий работоспособность функций
 * * * * * * * * * * * * * * * * */


#ifndef list_
#define list__

/* Звено списка */
struct _node
{
     int key;
     struct _node *link;
};
typedef struct _node node;

char isset(node *);
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * определяет, является  ли  список  множеством.
 * Под множеством следует понимать совокупность попарно различных элементов.
 * Множества неупорядоченные. Следует стремиться к минимизации числа операций сравнения
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

node *list2set(node *);
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * преобразовует список в множество
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

char equal(node *, node *);
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * определяет равенство двух множеств, представленных списками
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

char issubset(node *set, node *subset);
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * определяет, является ли множество subset подмножеством set
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

node *sort(node *);
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * упрядочивает по возрастанию  множество, представленное  списком. 
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

node *insert_ord(node *, int el);
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * вставляет элемент в упорядоченный список т.о., чтобы упорядоченность не нарушалась
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

node *whatsbefore(node *, int el);
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * получаюет в качестве параметрa указатель на начало списка и целое число
 * и возвращающую в качестве результата указатель на элемент,
 * предшедствующий элементу, содержащему заданное целое
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#endif